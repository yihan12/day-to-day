### 页面生成的过程: 
> 1.HTML被HTML解析器解析成DOM树  
> 2.CSS被CSS解析器解析成CSSOM树  
> 3.结合DOM树和CSSOM树，生成一颗渲染树(render tree)  
> 4.生成布局(flow)，即将所有渲染树的所有节点进行平面合成  
> 5.将布局绘制在(paint)在屏幕上
这五步，第一步到第三步非常快，耗时的是第四步和第五步。  

### 渲染：  
> 生成布局（flow）将渲染树的所有节点进行平面合成和将布局绘制（paint）在屏幕上这两步  

### 重绘重排:  
> 网页生成的时候，至少会渲染一次，用户访问过程中还会不断的重新渲染。  

#### 以下三种情况会导致网页重新渲染：  
- 修改DOM
- 修改样式表  
- 用户事件（比如鼠标悬停，页面滚动，输入框键入文字，改变窗口大小等等）  

++重新渲染，就需要重新生成布局和重新绘制。前者叫做重排（reflow），后者叫重绘（repaint）。++  

++重绘不一定导致重排，重排必然导致重绘++  

**提高网页性能，就是要降低重绘重排的频率和成本，尽量减少触发重新渲染。**  

一般规则：
- 样式表越简单，重绘重排a就越快
- 重排重绘的DOM元素层级越高，成本就越高
- table元素的重排和重绘成本，要高于div元素  


**提高性能的九个技巧:**  
1. DOM多个读操作（或多个写操作）应该放在一起，不要两个读操作之间加入一个写操作。  
2. 如果某个样式是通过重排得到的，那么最好缓存结果，避免下一次用到时，浏览器又要重排。  
3. 不要一条条地改变样式，而要通过改变class，或者csstext，一次性的改变样式。  
4. 尽量使用离线DOM，而不是真实的网面DOM来改变元素。比如Document Fragment对象，完成后再把这个对象加入DOM。再比如，使用cloneNode（）方法，在克隆的节点替换原始节点。  
5. 先将元素设为display：none(需要1次重排和重绘),然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘)。  
6. position属性为absolute或fixed的元素，重排开销会比较小，因为不要考虑他对其他元素的影响。  
7. 只有在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外visibility:hidden的元素只对重绘有影响，不影响重排。    
8. 使用虚拟DOM的脚本库，比如React等。  
9. 使用window.requestAnimationFrame()和window.requestIdleCallback这两个方法调节重新渲染。